name: Build and Release Extension

on:
  workflow_dispatch:
  push:
    branches: [ main ]
    paths:
      - 'public/manifest.json'
      - 'package.json'
      - 'src/**'
      - 'public/**'

jobs:
  build-and-release:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    permissions:
      contents: write
      packages: write
      pull-requests: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Get current version from manifest
      id: current_version
      run: |
        VERSION=$(node -p "JSON.parse(require('fs').readFileSync('public/manifest.json', 'utf8')).version")
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "Current version: $VERSION"

    - name: Check if version exists as tag
      id: check_tag
      run: |
        if git tag -l | grep -q "^v${{ steps.current_version.outputs.version }}$"; then
          echo "exists=true" >> $GITHUB_OUTPUT
          echo "Version v${{ steps.current_version.outputs.version }} already exists as a tag"
        else
          echo "exists=false" >> $GITHUB_OUTPUT
          echo "Version v${{ steps.current_version.outputs.version }} does not exist as a tag"
        fi

    - name: Increment patch version if needed
      id: version_check
      run: |
        CURRENT_VERSION="${{ steps.current_version.outputs.version }}"
        
        if [ "${{ steps.check_tag.outputs.exists }}" = "true" ]; then
          echo "Version already exists, incrementing patch version..."
          
          # Parse version components
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
          
          # Increment patch version
          NEW_PATCH=$((PATCH + 1))
          NEW_VERSION="$MAJOR.$MINOR.$NEW_PATCH"
          
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "version_changed=true" >> $GITHUB_OUTPUT
          echo "New version will be: $NEW_VERSION"
          
          # Update manifest.json
          node -e "
            const fs = require('fs');
            const manifest = JSON.parse(fs.readFileSync('public/manifest.json', 'utf8'));
            manifest.version = '$NEW_VERSION';
            fs.writeFileSync('public/manifest.json', JSON.stringify(manifest, null, 2) + '\n');
          "
          
          # Update package.json
          node -e "
            const fs = require('fs');
            const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
            pkg.version = '$NEW_VERSION';
            fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2) + '\n');
          "
          
        else
          echo "new_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "version_changed=false" >> $GITHUB_OUTPUT
          echo "Using existing version: $CURRENT_VERSION"
        fi

    - name: Commit version bump
      if: steps.version_check.outputs.version_changed == 'true' && github.ref == 'refs/heads/main'
      run: |
        echo "Committing version bump on main branch..."
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add public/manifest.json package.json
        git commit -m "Bump version to ${{ steps.version_check.outputs.new_version }} [skip ci]"
        git push origin HEAD:main

    - name: Build extension
      run: npm run build:extension

    - name: Get commit messages since last release
      id: get_commits
      run: |
        # Get the latest release tag
        LATEST_TAG=$(git tag -l "v*" | sort -V | tail -n 1)
        
        if [ -z "$LATEST_TAG" ]; then
          echo "No previous releases found, getting all commits"
          COMMIT_MESSAGES=$(git log --oneline --pretty=format:"- %s" HEAD)
        else
          echo "Getting commits since $LATEST_TAG"
          COMMIT_MESSAGES=$(git log --oneline --pretty=format:"- %s" $LATEST_TAG..HEAD)
        fi
        
        # Handle empty commit messages
        if [ -z "$COMMIT_MESSAGES" ]; then
          COMMIT_MESSAGES="- No new commits since last release"
        fi
        
        # Save commit messages to output, escaping newlines for GitHub Actions
        echo "commit_messages<<EOF" >> $GITHUB_OUTPUT
        echo "$COMMIT_MESSAGES" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        echo "Commit messages since last release:"
        echo "$COMMIT_MESSAGES"

    - name: Create release zip
      run: |
        VERSION="${{ steps.version_check.outputs.new_version }}"
        cd dist
        
        # Create a clean zip with just the extension files
        if [ -d "$VERSION" ]; then
          cd "$VERSION"
          zip -r "../genni-extension-v$VERSION.zip" .
          cd ..
        else
          # Fallback: zip the entire dist folder contents
          zip -r "genni-extension-v$VERSION.zip" . -x "*.zip"
        fi
        
        echo "Created zip file: genni-extension-v$VERSION.zip"
        ls -la *.zip

    - name: Create GitHub Release
      id: create_release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: v${{ steps.version_check.outputs.new_version }}
        release_name: Genni Extension v${{ steps.version_check.outputs.new_version }}
        body: |
          ## Genni - Analytics Mocking Tool v${{ steps.version_check.outputs.new_version }}
          
          ### üì¶ Installation
          1. Download the `genni-extension-v${{ steps.version_check.outputs.new_version }}.zip` file below
          2. Extract the zip file
          3. Open Chrome/Edge and navigate to `chrome://extensions/` or `edge://extensions/`
          4. Enable "Developer mode"
          5. Click "Load unpacked" and select the extracted folder
          
          ### üîÑ Changes
          ${{ steps.version_check.outputs.version_changed == 'true' && 'Automated patch version bump' || 'New release with version from manifest' }}
          
          ### üìù Commits since last release
          ${{ steps.get_commits.outputs.commit_messages }}
          
          Built automatically from commit ${{ github.sha }}
        draft: false
        prerelease: false

    - name: Upload Release Asset
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: dist/genni-extension-v${{ steps.version_check.outputs.new_version }}.zip
        asset_name: genni-extension-v${{ steps.version_check.outputs.new_version }}.zip
        asset_content_type: application/zip

    - name: Output release info
      run: |
        echo "üéâ Release created successfully!"
        echo "üì¶ Version: v${{ steps.version_check.outputs.new_version }}"
        echo "üîó Release URL: ${{ steps.create_release.outputs.html_url }}"
